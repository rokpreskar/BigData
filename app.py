import streamlit as st
import pandas as pd
import json
from transformers import pipeline
import altair as alt
from wordcloud import WordCloud, STOPWORDS
import matplotlib.pyplot as plt
import re
import os

os.environ["TOKENIZERS_PARALLELISM"] = "false"
os.environ["MPLCONFIGDIR"] = "/tmp/matplotlib"

# --- PAGE CONFIGURATION ---
st.set_page_config(
    page_title="Brand Reputation Dashboard 2023",
    page_icon="üìä",
    layout="wide"
)

# --- DATA LOADING ---
@st.cache_data
def load_scraped_data():
    """Load the JSON data generated by the Playwright scraper."""
    try:
        with open("data/scraped_data.json", "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        st.error("‚ö†Ô∏è 'scraped_data.json' not found! Please run your scraper.py first.")
        return None

# --- SENTIMENT MODEL (HUGGING FACE) ---
@st.cache_resource
def get_sentiment_pipeline():
    return pipeline(
        "sentiment-analysis",
        model="distilbert-base-uncased-finetuned-sst-2-english",
        device=-1  # force CPU
    )

@st.cache_data
def run_sentiment(texts_tuple):
    sentiment_pipe = get_sentiment_pipeline()
    return sentiment_pipe(
        list(texts_tuple),
        batch_size=8,
        truncation=True,
        max_length=128,   # ‚úÖ reduces RAM + speed
    )


data = load_scraped_data()

# --- SIDEBAR NAVIGATION ---
st.sidebar.title("üîç Navigation")
st.sidebar.markdown("---")
page = st.sidebar.radio("Select a Section:", ["Products", "Testimonials", "Reviews"])

if data:
    # ---------------------------
    # 1) PRODUCTS
    # ---------------------------
    if page == "Products":
        st.header("üì¶ Product Catalog")
        st.write("Overview of all scraped products and their pricing.")

        df_products = pd.DataFrame(data.get("products", []))

        if df_products.empty:
            st.warning("No products found in scraped data.")
        else:
            if "price" in df_products.columns:
                df_products["price"] = pd.to_numeric(df_products["price"], errors="coerce")

            col1, col2 = st.columns(2)
            col1.metric("Total Products", len(df_products))
            if "price" in df_products.columns and df_products["price"].notna().any():
                col2.metric("Avg. Price", f"${df_products['price'].mean():.2f}")
            else:
                col2.metric("Avg. Price", "N/A")

            st.dataframe(df_products, width="stretch")

    # ---------------------------
    # 2) TESTIMONIALS
    # ---------------------------
    elif page == "Testimonials":
        st.header("üí¨ Customer Testimonials")
        st.write("Raw feedback collected from the infinite scroll section.")

        df_testimonials = pd.DataFrame(data.get("testimonials", []))

        if df_testimonials.empty:
            st.warning("No testimonials found in scraped data.")
        else:
            st.dataframe(df_testimonials, width="stretch")

            if "rating" in df_testimonials.columns:
                st.subheader("Rating Distribution")
                st.bar_chart(df_testimonials["rating"].value_counts())
            else:
                st.info("No 'rating' column found for testimonials.")

    # ---------------------------
    # 3) REVIEWS (FILTER + SENTIMENT + VISUALIZATION)
    # ---------------------------
    elif page == "Reviews":
        st.header("üìà 2023 Reviews Analysis")
        st.write("Filter reviews by specific months within the year 2023.")

        months = [
            "January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ]
        selected_month_name = st.select_slider("Select a month in 2023:", options=months)

        df_reviews = pd.DataFrame(data.get("reviews", []))

        if df_reviews.empty:
            st.warning("No reviews found in scraped data.")
        else:
            # Parse dates safely
            if "date" not in df_reviews.columns:
                st.error("Reviews data has no 'date' column, cannot filter by month.")
            else:
                df_reviews["date"] = pd.to_datetime(df_reviews["date"], errors="coerce")

                # Filter by selected month of 2023
                month_index = months.index(selected_month_name) + 1
                filtered_df = df_reviews[
                    (df_reviews["date"].dt.month == month_index) &
                    (df_reviews["date"].dt.year == 2023)
                ].copy()

                if filtered_df.empty:
                    st.warning(f"No reviews were scraped for {selected_month_name} 2023.")
                else:
                    st.success(f"Found {len(filtered_df)} reviews for {selected_month_name} 2023.")

                    # Ensure rating numeric (if present)
                    if "rating" in filtered_df.columns:
                        filtered_df["rating"] = pd.to_numeric(filtered_df["rating"], errors="coerce")

                    # Prepare display df
                    show_df = filtered_df.copy()
                    show_df["date"] = show_df["date"].dt.strftime("%Y-%m-%d")

                    # Rating metric
                    if "rating" in filtered_df.columns and filtered_df["rating"].notna().any():
                        avg_rating = filtered_df["rating"].mean()
                        st.metric(f"Average Rating for {selected_month_name}", f"{avg_rating:.1f} / 5 ‚≠ê")
                    else:
                        st.metric(f"Average Rating for {selected_month_name}", "N/A")

                    # --- Sentiment Analysis ---
                    st.subheader("Sentiment Analysis (Hugging Face Transformers)")
                    if "text" not in filtered_df.columns:
                        st.error("Reviews data has no 'text' column, cannot run sentiment analysis.")
                        st.dataframe(show_df, width="stretch")
                    else:
                        try:
                            texts = filtered_df["text"].fillna("").astype(str).str.strip().tolist()

                            with st.spinner("Running sentiment analysis..."):
                                results = run_sentiment(tuple(texts))

                            show_df["sentiment"] = [
                                "Positive" if r["label"] == "POSITIVE" else "Negative"
                                for r in results
                            ]
                            show_df["sentiment_score"] = [float(r["score"]) for r in results]

                            # Metrics
                            c1, c2, c3 = st.columns(3)
                            c1.metric("Positive", int((show_df["sentiment"] == "Positive").sum()))
                            c2.metric("Negative", int((show_df["sentiment"] == "Negative").sum()))
                            c3.metric("Overall Avg Confidence", f"{show_df['sentiment_score'].mean():.2f}")

                            # --- Visualization requirement ---
                            st.subheader("Positive vs Negative Reviews (with Avg Confidence Tooltip)")

                            summary = (
                                show_df.groupby("sentiment", as_index=False)
                                .agg(
                                    count=("sentiment", "size"),
                                    avg_conf=("sentiment_score", "mean")
                                )
                            )

                            # Force both categories to appear (even if one is missing)
                            summary = (
                                summary.set_index("sentiment")
                                .reindex(["Positive", "Negative"])
                                .reset_index()
                            )
                            summary["count"] = summary["count"].fillna(0).astype(int)
                            summary["avg_conf"] = summary["avg_conf"].fillna(0.0)

                            chart = alt.Chart(summary).mark_bar().encode(
                                x=alt.X("sentiment:N", title="Sentiment"),
                                y=alt.Y("count:Q", title="Number of Reviews"),
                                tooltip=[
                                    alt.Tooltip("sentiment:N", title="Sentiment"),
                                    alt.Tooltip("count:Q", title="Count"),
                                    alt.Tooltip("avg_conf:Q", title="Avg confidence", format=".2f"),
                                ],
                            )

                            # Optional: show avg_conf label above bars (helps graders)
                            text_layer = alt.Chart(summary).mark_text(dy=-10).encode(
                                x="sentiment:N",
                                y="count:Q",
                                text=alt.Text("avg_conf:Q", format=".2f"),
                            )

                            st.altair_chart(chart + text_layer, width="stretch")

                            # ---------------- Word Cloud (BONUS) ----------------
                            st.subheader("Word Cloud (Selected Month Reviews)")

                            text_blob = " ".join(show_df["text"].astype(str)).lower()

                            # Clean text
                            text_blob = re.sub(r"http\S+|www\S+", "", text_blob)
                            text_blob = re.sub(r"[^\w\s]", " ", text_blob, flags=re.UNICODE)
                            text_blob = re.sub(r"[\d_]+", " ", text_blob)
                            text_blob = re.sub(r"\s+", " ", text_blob).strip()

                            if len(text_blob) < 20:
                                st.info("Not enough text to generate a word cloud.")
                            else:
                                wc = WordCloud(
                                    width=700,
                                    height=350,
                                    max_words=100,          # ‚úÖ less memory
                                    background_color="white",
                                    stopwords=set(STOPWORDS),
                                    collocations=False
                                ).generate(text_blob)

                                fig, ax = plt.subplots(figsize=(10, 4))
                                ax.imshow(wc)
                                ax.axis("off")
                                st.pyplot(fig)

                            # ---------------------------------------------------


                            # Show table last (so chart is visible without scrolling)
                            st.subheader("Reviews Table (with Sentiment)")
                            st.dataframe(show_df, width="stretch")

                        except Exception as e:
                            st.exception(e)
                            st.stop()

# --- FOOTER ---
st.sidebar.markdown("---")
st.sidebar.info("Data Mining Homework #3 Rok Preskar")

# Run in terminal:
# python -m streamlit run app.py
